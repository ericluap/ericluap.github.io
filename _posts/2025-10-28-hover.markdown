---
layout: post
title: "You can modify hover info in Lean!"
date: 2025-10-28
categories: lean
---

When you hover over code in Lean, it shows some information:
![Hovering over a string](/assets/images/hover/hover_image_1.png){: .center-image style="width: 40%;"}
(That's the result of me hovering over the text `"hi"` in this example command. It shows that its type is a `String`.)

I can modify what I do in the code defining `#test` and change what the hover says:
![The hover now shows different text](/assets/images/hover/hover_image_2.png){: .center-image style="width: 45%;"}
I think that's pretty neat.

## How is this possible?
When you hover over something, some program is called whose job is to return the information about the text you are hovering above. That program needs to know what all the code in the file *means* in order to say what the type information is.

Lean's metaprogramming means that in a Lean file we can control what a piece of syntax means. And thus, we control the hovers!

## An example
Let's see an example. [Try hovering yourself in the online editor.](https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAGQKYEMB2AoDSA2KBGcARAMQxIDO8RcSAXOVCHHXAMYQgjoAmcAvAD44UJDACuUNHAAUASixlK1ABbAiQA)
```lean
import Lean

elab "#test " e:term : command => return ()

#test "hi"
```

Here we define a new piece of syntax `#test` that takes in one argument `e` and overall it is a `command`. And then we provide what that code means, which here is nothing.

So on the next line `#test "hi"` does nothing. And when you hover over it, nothing is displayed because that code has no meaning. Even though it may look like `"hi"` is a string, it has no hover because we gave this code no meaning.

Now let's give `"hi"` its normal meaning. Lean calls the process of giving code meaning *elaboration*. So we are going to elaborate `e`. [Online editor](https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAGQKYEMB2AoCYlsavAUQBsUAjOAYQhBHQBM4AVJKEDDJUigIgGIYSAM7wecJAC5BbOBLgBjGnTSMAvAD44xYADMYLNiXIBZOPQgY4WpPAD6cQAmE47gZDi4aCGiQcBw0QAWwDxAA)
```lean
import Lean
open Lean Elab Command Term

elab "#test " e:term : command => liftTermElabM do
  let _ ← elabTerm e none

#test "hi"
```
Since we have called `elabTerm e none`, we can now hover over `"hi"` and see that its type is a `String`.

Let's make it so that hovering over `"hi"` shows instead what would happen if we were hovering over `5`. [Online editor](https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAGQKYEMB2AoUlZwIoCOGEYSaiq5AogDYoBG+RGSdjARAMQxIDO87OEgBcPKCDjC4AYwggQ6ACZwAvAD44iiBjhwwAV14ALAJJoAZhGQpzcABQA6COYAqScWctwA3jt1C2aBQYaEkVOAd0CDQATxAIQz9dfgAPMKEkuBppGDThcIckcBgYzKQU0hykRRcY0gB+dLRopDKKqHSCOwBWAEo/AF9+jG4+ASNgdiA)
```lean
import Lean
import Qq
open Lean Elab Qq

elab "#test " e:term : command => do
  pushInfoLeaf (.ofTermInfo {
    elaborator := .anonymous
    stx := e
    lctx := .empty
    expectedType? := none
    expr := q(5)
  })

#test "hi"
```
And when we hover over `"hi"` we now see the following:
![Hover now shows information for the number `5`](/assets/images/hover/hover_image_3.png){: .center-image style="width: 35%;"}

What's going on in this code? The program that handles the hover information is specifically getting information from the `InfoTree`. We can add information to this tree for a piece of syntax using the `pushInfoLeaf` function. Here we call `pushInfoLeaf` and tell it that we're going to give it information about a term using `.ofTermInfo`.

`.ofTermInfo` wants a lot of information. The two important things are `stx` and `expr`. The field `stx` says what syntax we are talking about and so we pass it `e`. Then `expr` is what that syntax means. We say that here it means `5`. And thus our hover shows `5 : Nat`!
